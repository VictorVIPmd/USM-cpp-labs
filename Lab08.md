// Файл HeapInt.h
#pragma once // 1
#include <cassert>

class HeapInt
{
private:
    int heapValue; // 2

public:
    // 3
    inline HeapInt(int val) 
        // 4
        : heapValue(new int{ val })
    {
    }

    inline ~HeapInt()
    {
        // Заметка: delete проверяет на nullptr сам.
        delete heapValue; // 5
    }

    inline int& asRef()
    {
        assert(heapValue != nullptr); // 6
        return heapValue;
    }

    HeapInt(const HeapInt& hello); // 7
    HeapInt(HeapInt&& hello);
    void operator=(const HeapInt& hello);
    void operator=(HeapInt&& hello);
};

// Файл main.
#include "HeapInt.h"

void constructors()
{
    HeapInt a{5}; // 8
    HeapInt b{a}; // 9
    HeapInt c{std::move(a)}; // 10
    HeapInt d = b; // 11
    HeapInt e = std::move(b); // 12
    d = std::move(c); // 13
    d = e; // 14
}

// Файл HeapInt.
#include "HeapInt.h"

// ... 15

_____________________________________


1. Почему поле heapValue (2) приватное?  
    Это позволяет избежать прямой модификации heapValue извне и защищает его от случайного присвоения или освобождения памяти.

2. Что означает этот синтаксис (4)? Как его расписать в теле конструктора?  
    Этот синтаксис инициализирует heapValue с выделением динамической памяти. В теле конструктора это можно переписать следующим образом:
   
    HeapInt(int val) {
       heapValue = new int{ val };
    }

3. Как скомпилировать это с помощью GCC?
    g++ main.cpp HeapInt.cpp -o program

4. Зачем (1) #pragma once? Какую ситуацию это предотвратит?  
    #pragma once предотвращает многократное включение файла заголовка в одном компиляционном модуле, даже если он будет подключен несколько раз. Это устраняет возможность ошибок при многократной компиляции одного и того же кода.

5. Почему (3) определена как inline?  
    inline уменьшает накладные расходы на вызов функции, поскольку компилятор может встроить код метода в место его вызова.

6. Как можно обойти ограничение, что конструктор или функция должны быть inline?  
    Чтобы избежать использования inline, можно определить конструктор или метод вне класса в файле, Например:
   
    HeapInt::HeapInt(int val) : heapValue(new int{ val }) {}



7. Зачем на (6) нужна проверка assert(heapValue != nullptr), если int не может быть nullptr?  
   Проверка assert на nullptr необходима для безопасности, чтобы убедиться, что heapValue корректно инициализирован и не был случайно освобожден или утерян в результате некорректных операций.

8. Объясните, какой из конструкторов или перегруженных операторов вызовется для (8-14). Какие из них эквивалентны?
   - (8):  wВызывает конструктор HeapInt(int val) для инициализации a.
   - (9):  Вызывает конструктор копирования HeapInt(const HeapInt&), создавая копию a для b.
   - (10): Вызывает перемещающий конструктор HeapInt(HeapInt&&), перемещая a в c.
   - (11): Вызывает конструктор копирования HeapInt(const HeapInt&), копируя b в d.
   - (12): Вызывает перемещающий конструктор HeapInt(HeapInt&&), перемещая b в e.
   - (13): Вызывает оператор перемещающего присваивания operator=(HeapInt&&), перемещая c в d.
   - (14): Вызывает оператор присваивания копированием operator=(const HeapInt&), копируя e в d.
   
   Эквивалентные: (9) и (11), так как оба используют копирование.

9. Как запретить синтаксис на (11-12)?  
    Можно объявить конструкторы копирования и перемещения delete:
   
    HeapInt(const HeapInt&) = delete;
    HeapInt(HeapInt&&) = delete;
   

10. Определите на (15) конструкторы и операторы на (7).
   
   // Конструктор копирования
   HeapInt::HeapInt(const HeapInt& hello) : heapValue(new int{ hello.heapValue }) {}

   // Конструктор перемещения
   HeapInt::HeapInt(HeapInt&& hello) : heapValue(hello.heapValue) {...}

   // Оператор присваивания копированием
   void HeapInt::operator=(const HeapInt& hello) {...}

   // Оператор присваивания перемещением
   void HeapInt::operator=(HeapInt&& hello) {...}
   

11. В какой еще ситуации вызовется rvalue reference перегрузка конструктора или оператора присваивания?  
    Когда временный объект передается как аргумент (результат функции)

12. Сколько раз вызовется деструктор для типа HeapInt после (14)?  
    5 раз — для каждого из объектов a, b, c, d и e, когда они выйдут из области видимости.

13. Объясните, какая по вашему мнению была мотивация того, что у этого типа не был определен дефолтный конструктор?
    Дефолтный конструктор не определен, так как класс HeapInt требует начального значения для инициализации динамической переменной heapValue. Без инициализации heapValue объект не имел бы валидного значения, что нарушило бы правило RAII.

14. Почему считывать значение объекта после применения std::move — это неправильная операция?  
    std::move переводит объект в состояние «перемещения», оставляя его в потенциально неопределенном состоянии (например, его указатели могут быть nullptr). Поэтому попытка обращения к такому объекту после move приводит к неопределенному поведению.

15. Создайте функцию void swap(HeapInt& a, HeapInt& b), которая меняет значения без выделения новой динамической памяти.
   
    void swap(HeapInt& a, HeapInt& b) {
        int temp = a.heapValue;
        a.heapValue = b.heapValue;
        b.heapValue = temp;
    }
   