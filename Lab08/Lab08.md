// Тут теоритические ответы, функция я добавлял в файлы

1. Почему поле heapValue (2) приватное?  
    Это позволяет избежать прямой модификации heapValue извне и защищает его от случайного присвоения или освобождения памяти.

2. Что означает этот синтаксис (4)? Как его расписать в теле конструктора?  
    

3. Как скомпилировать это с помощью GCC?
    g++ main.cpp HeapInt.cpp -o program

4. Зачем (1) #pragma once? Какую ситуацию это предотвратит?  
    #pragma once предотвращает многократное включение файла заголовка в одном компиляционном модуле, даже если он будет подключен несколько раз. Это устраняет возможность ошибок при многократной компиляции одного и того же кода.

5. Почему (3) определена как inline?  
    inline уменьшает накладные расходы на вызов функции, поскольку компилятор может встроить код метода в место его вызова.

6. Как можно обойти ограничение, что конструктор или функция должны быть inline?

    Можно определить конструктор или метод вне класса в файле, то есть:
    HeapInt::HeapInt(int val) : heapValue(new int{ val }) {}

7. Зачем на (6) нужна проверка assert(heapValue != nullptr), если int не может быть nullptr?  
   Проверка assert на nullptr необходима для безопасности, чтобы убедиться, что heapValue корректно инициализирован и не был случайно освобожден или утерян в результате некорректных операций.

8. Объясните, какой из конструкторов или перегруженных операторов вызовется для (8-14). Какие из них эквивалентны?
   - (8):  wВызывает конструктор HeapInt(int val) для инициализации a.
   - (9):  Вызывает конструктор копирования HeapInt(const HeapInt&), создавая копию a для b.
   - (10): Вызывает перемещающий конструктор HeapInt(HeapInt&&), перемещая a в c.
   - (11): Вызывает конструктор копирования HeapInt(const HeapInt&), копируя b в d.
   - (12): Вызывает перемещающий конструктор HeapInt(HeapInt&&), перемещая b в e.
   - (13): Вызывает оператор перемещающего присваивания operator=(HeapInt&&), перемещая c в d.
   - (14): Вызывает оператор присваивания копированием operator=(const HeapInt&), копируя e в d.
   
   Эквивалентные: (9) и (11), так как оба используют копирование.

9. Как запретить синтаксис на (11-12)?  
    Можно объявить конструкторы копирования и перемещения delete:
   
    HeapInt(const HeapInt&) = delete;
    HeapInt(HeapInt&&) = delete;
   

10. Определите на (15) конструкторы и операторы на (7).
   
   // Конструктор копирования
   HeapInt::HeapInt(const HeapInt& hello) : heapValue(new int{ hello.heapValue }) {}

   // Конструктор перемещения
   HeapInt::HeapInt(HeapInt&& hello) : heapValue(hello.heapValue) {...}

   // Оператор присваивания копированием
   void HeapInt::operator=(const HeapInt& hello) {...}

   // Оператор присваивания перемещением
   void HeapInt::operator=(HeapInt&& hello) {...}
   

11. В какой еще ситуации вызовется rvalue reference перегрузка конструктора или оператора присваивания?  
    Когда временный объект передается как аргумент (результат функции)

12. Сколько раз вызовется деструктор для типа HeapInt после (14)?  
    5 раз — для каждого из объектов a, b, c, d и e, когда они выйдут из области видимости.

13. Объясните, какая по вашему мнению была мотивация того, что у этого типа не был определен дефолтный конструктор?
    Дефолтный конструктор не определен, так как класс HeapInt требует начального значения для инициализации динамической переменной heapValue. Без инициализации heapValue объект не имел бы валидного значения, что нарушило бы правило RAII.

14. Почему считывать значение объекта после применения std::move — это неправильная операция?  
    std::move переводит объект в состояние «перемещения», оставляя его в потенциально неопределенном состоянии (например, его указатели могут быть nullptr). Поэтому попытка обращения к такому объекту после move приводит к неопределенному поведению.

15. Создайте функцию void swap(HeapInt& a, HeapInt& b), которая меняет значения без выделения новой динамической памяти.  